#version 460

#extension GL_GOOGLE_include_directive : require

layout(set = 0, binding = 0) uniform Variables
{
	mat4 view;
	mat4 projection;
	vec4 viewPosition;
	vec4 lightDirection;
	vec4 resolution;
	vec4 terrainOffset;
	vec4 heightmapOffsets[8];
} variables;

layout(set = 1, binding = 0, rgba8) uniform image2D target;
layout(set = 1, binding = 1) uniform Config { vec4 sizes; } config;

layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

#include "noise.glsl"
#include "packing.glsl"

const int res = 4096;
const int iterations = 2;
const int iterationDiv = int(pow(2, iterations));
const int iterationRes = res / iterationDiv;

void main()
{
	ivec2 invocationID = ivec2(gl_GlobalInvocationID.xy);
	invocationID.x += iterationRes * (int(config.sizes.w) % iterationDiv);
	invocationID.y += iterationRes * (int(config.sizes.w) / iterationDiv);
	//if (int(config.sizes.w) % 2 == 1) invocationID.x += res / 2;
	//if (int(config.sizes.w) / 2 > 0) invocationID.y += res / 2;
	vec2 dispatchUV = vec2(float(invocationID.x) / float(res), float(invocationID.y) / float(res));
	vec2 uv = (dispatchUV - vec2(0.5, 0.5)) * config.sizes.x;
	
	//if (config.sizes.x > 0.05 && max(abs(dispatchUV.x - 0.5), abs(dispatchUV.y - 0.5)) < 0.125) return;

	//float height = TerrainData(uv + variables.terrainOffset.xz, int(variables.terrainOffset.w), true).x;
	//vec3 tnoise = TerrainData(uv + variables.terrainOffset.xz, int(variables.terrainOffset.w), 0.00001, false);
	vec3 tnoise = TerrainData(uv + config.sizes.yz, int(variables.terrainOffset.w), 0.00001, false);

	vec3 normal = DerivativeToNormal(vec2(tnoise.y, tnoise.z)) * 0.5 + 0.5;
	//vec2 derivatives = vec2(tnoise.y, tnoise.z) * 0.5 + 0.5;
	vec2 derivatives = normal.xz;
	vec2 packedHeight = packFloatToRG8(tnoise.x);

	//imageStore(target, invocationID.xy, vec4(tnoise.x, normal.x, normal.y, normal.z));
	imageStore(target, invocationID.xy, vec4(packedHeight.xy, derivatives.xy));
}