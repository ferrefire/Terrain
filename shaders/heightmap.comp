#version 460

#extension GL_GOOGLE_include_directive : require

#include "variables.glsl"

layout(set = 1, binding = 0, rgba16) uniform image2D target16;
layout(set = 1, binding = 1, rgba8) uniform image2D target8;
layout(set = 1, binding = 2, std140) uniform Config { vec4 sizes; } config;
layout(set = 1, binding = 3, std140) uniform Settings 
{ 
	float seed;
	float erodeFactor;
	float steepness;
} settings;

layout(local_size_x = 8, local_size_y = 8) in;

#include "noise.glsl"
#include "packing.glsl"

const int res = 2048;
const int iterations = 2;
const int iterationDiv = int(pow(2, iterations));
const int iterationRes = res / iterationDiv;

const float heightMapBase = 0.075;

void main()
{
	ivec2 invocationID = ivec2(gl_GlobalInvocationID.xy);
	invocationID.x += iterationRes * (int(config.sizes.w) % iterationDiv);
	invocationID.y += iterationRes * (int(config.sizes.w) / iterationDiv);
	vec2 dispatchUV = vec2(float(invocationID.x) / float(res), float(invocationID.y) / float(res));
	//vec2 uv = (dispatchUV - vec2(0.5, 0.5)) * config.sizes.x;
	vec2 uv = (dispatchUV - vec2(0.5, 0.5)) * (heightMapBase * pow(2.0, config.sizes.x));
	
	//if (config.sizes.x > 0.05 && max(abs(dispatchUV.x - 0.5), abs(dispatchUV.y - 0.5)) < 0.125) return;

	//float height = TerrainData(uv + variables.terrainOffset.xz, int(variables.terrainOffset.w), true).x;
	//vec3 tnoise = TerrainData(uv + variables.terrainOffset.xz, int(variables.terrainOffset.w), 0.00001, false);
	//vec3 tnoise = TerrainData(uv + config.sizes.yz, int(variables.terrainOffset.w), 0.00001, false);
	float normalDis = mix(0.00001, 0.0001, clamp((config.sizes.x / cascadeCount), 0.0, 1.0));
	//int octaveDecrease = int(floor(mix(0.0, 7.0, clamp((config.sizes.x / cascadeCount), 0.0, 1.0))));
	int octaveDecrease = int(config.sizes.x);
	vec3 tnoise = TerrainData(uv + config.sizes.yz, 15 - octaveDecrease, normalDis, false, settings.seed, settings.erodeFactor, settings.steepness);
	//vec3 tnoise = TerrainData(uv + config.sizes.yz, int(variables.terrainOffset.w), 0.0001, false);
	//vec3 tnoise = TerrainData(uv + config.sizes.yz, int(variables.terrainOffset.w), 0.00001, false);

	vec3 normal = DerivativeToNormal(vec2(tnoise.y, tnoise.z)) * 0.5 + 0.5;
	//vec2 derivatives = vec2(tnoise.y, tnoise.z) * 0.5 + 0.5;
	vec2 derivatives = normal.xz;
	vec2 packedHeight = packFloatToRG8(tnoise.x);
	//vec2 packedHeight = packFloatToRG16(tnoise.x);

	//imageStore(target, invocationID.xy, vec4(tnoise.x, normal.x, normal.y, normal.z));
	if (config.sizes.x == 0) {imageStore(target16, invocationID.xy, vec4(packedHeight.xy, derivatives.xy));}
	else {imageStore(target8, invocationID.xy, vec4(packedHeight.xy, derivatives.xy));}
}