#version 460

#extension GL_GOOGLE_include_directive : require

#include "atmosphere.glsl"

#include "variables.glsl"

#include "terrainFunctions.glsl"

layout(set = 1, binding = 0, rgba16f) uniform readonly image2D transmittanceImage;
layout(set = 1, binding = 1, rgba16f) uniform readonly image2D scatteringImage;
layout(set = 1, binding = 2, rgba16f) uniform readonly image2D skyImage;
layout(set = 1, binding = 3, rgba16f) uniform image3D aerialImage;

layout(local_size_x = 64, local_size_y = 1, local_size_z = 1) in;

vec3 MultiScattering(vec3 worldPosition, float viewAngle)
{
	vec2 uv = clamp(vec2(viewAngle * 0.5 + 0.5, (length(worldPosition) - bottomRadius) / (topRadius - bottomRadius)), 0.0, 1.0);
	uv = vec2(UnitToSubUV(uv.x, scatteringDimensions.x), UnitToSubUV(uv.y, scatteringDimensions.y));

	ivec2 coords = ivec2(uv * scatteringDimensions);

	return (imageLoad(scatteringImage, coords).rgb);
}

struct TransmittedLuminance
{
	vec3 luminance;
	vec3 transmittance;
};

TransmittedLuminance IntegrateScatteredLuminance(vec3 worldPosition, vec3 worldDirection, vec3 sunDirection, int sampleCount, float maxDistance)
{
	TransmittedLuminance result = TransmittedLuminance(vec3(0.0), vec3(0.0));

	float surfaceDistance = IntersectSphere(worldPosition, worldDirection, vec3(0.0), bottomRadius);
	float atmosphereDistance = IntersectSphere(worldPosition, worldDirection, vec3(0.0), topRadius);
	
	float integrationLength = 0.0;

	if (surfaceDistance == -1.0 && atmosphereDistance == -1.0) {return (result);}
	else if (surfaceDistance == -1.0 && atmosphereDistance > 0.0) {integrationLength = atmosphereDistance;}
	else if (surfaceDistance > 0.0 && atmosphereDistance == -1.0) {integrationLength = surfaceDistance;}
	else {integrationLength = min(surfaceDistance, atmosphereDistance);}

	integrationLength = min(integrationLength, maxDistance);

	float theta = dot(sunDirection, worldDirection);
	float miePhaseValue = MiePhase(atmosphereData.miePhaseFunction, -theta);
	float rayPhaseValue = RayleighPhase(theta);

	float oldRayShift = 0.0;
	float integrationStep = 0.0;

	vec3 accumulatedTransmittance = vec3(1.0);
	vec3 accumulatedLight = vec3(0.0);

	for (int i = 0; i < sampleCount; i++)
	{
		float newRayShift = integrationLength * (float(i) + 0.3) / sampleCount;
		integrationStep = newRayShift - oldRayShift;

		vec3 rayPosition = worldPosition + newRayShift * worldDirection;
		oldRayShift = newRayShift;

		//vec3 rayPosition = worldPosition + integrationStep * worldDirection;

		ScatteringResult mediumScattering = SampleScatteringResult(rayPosition);
		vec3 mediumExtinction = SampleExtinction(rayPosition);

		vec3 up = normalize(rayPosition);
		vec2 paramT = vec2(length(rayPosition), dot(sunDirection, up));
		vec2 uvT = TransmittanceToUV(paramT);
		ivec2 uvTCoords = ivec2(uvT * transmittanceDimensions);

		vec3 sunTransmittance = imageLoad(transmittanceImage, uvTCoords).rgb;
		vec3 phaseScattering = mediumScattering.mie * miePhaseValue + mediumScattering.ray * rayPhaseValue;

		float raySurfaceDistance = IntersectSphere(rayPosition, sunDirection, atmosphereData.offsetRadius * up, bottomRadius);
		float inShadow = raySurfaceDistance == -1.0 ? 1.0 : 0.0;

		//if (inShadow == 1.0) {inShadow = TerrainShadow(rayPosition - vec3(0.0, 2500.0 + (variables.terrainOffset.y * 10000.0) + bottomRadius, 0.0));}
		if (inShadow == 1.0)
		{
			vec3 realPos = rayPosition - vec3(0.0, bottomRadius, 0.0);
			realPos /= atmosphereData.cameraScale;
			realPos -= vec3(0.0, 2500.0, 0.0);
			//inShadow = TerrainShadow(realPos);
			inShadow = TerrainShadow(realPos, 0, true);
			//if (inShadow < 1.0) {inShadow *= inShadow;}
		}

		vec3 multiScatteredLuminance = MultiScattering(rayPosition, dot(sunDirection, up));

		vec3 sunLight = inShadow * sunTransmittance * phaseScattering + multiScatteredLuminance * (mediumScattering.ray + mediumScattering.mie);

		vec3 transmittanceIncrease = exp(-(mediumExtinction * integrationStep));
		vec3 sunLightIntegration = (sunLight - sunLight * transmittanceIncrease) / mediumExtinction;

		accumulatedLight += accumulatedTransmittance * sunLightIntegration;
		accumulatedTransmittance *= transmittanceIncrease;
	}

	result.luminance = accumulatedLight;
	result.transmittance = accumulatedTransmittance;

	return (result);
}

void main()
{
	mat4 invViewProjMat = inverse(variables.projection * variables.view);
    vec2 pixPos = vec2(gl_GlobalInvocationID.xy + vec2(0.5, 0.5)) / aerialDimensions.xy;
    vec3 ClipSpace = vec3(pixPos * vec2(2.0, 2.0) - vec2(1.0, 1.0), 0.5);
    
    vec4 Hpos = invViewProjMat * vec4(ClipSpace, 1.0);

	vec3 sunDirection = variables.lightDirection.xyz;

	vec3 viewPosition = (variables.viewPosition.xyz + vec3(0.0, 2500.0 + (variables.terrainOffset.y * 10000.0), 0.0)) * atmosphereData.cameraScale;
    vec3 worldDirection = normalize(Hpos.xyz / Hpos.w - variables.viewPosition.xyz);
	vec3 worldPosition = viewPosition + vec3(0.0, bottomRadius, 0.0);

	float slice = ((float(gl_GlobalInvocationID.z) + 0.5) / aerialDimensions.z);
    slice *= slice;
    slice *= aerialDimensions.z;

	float tMax = slice * 4.0;
    vec3 newWorldPosition = worldPosition + tMax * worldDirection;
	float viewHeight = length(newWorldPosition);

	if (viewHeight <= (bottomRadius + atmosphereData.offsetRadius))
    {
        newWorldPosition = normalize(newWorldPosition) * (bottomRadius + atmosphereData.offsetRadius + 0.001);
        worldDirection = normalize(newWorldPosition - worldPosition);
        tMax = length(newWorldPosition - worldPosition);
    }

	viewHeight = length(worldPosition);

	if (viewHeight >= topRadius)
	{
		vec3 previousWorldPosition = worldPosition;
		if (!MoveToAtmosphere(worldPosition, worldDirection))
		{
			imageStore(aerialImage, ivec3(gl_GlobalInvocationID.xyz), vec4( 0.0, 0.0, 0.0, 1.0));
            return;
		}

		float atmosphereDistance = length(previousWorldPosition - worldPosition);
		if (tMax < atmosphereDistance)
		{
			imageStore(aerialImage, ivec3(gl_GlobalInvocationID.xyz), vec4( 0.0, 0.0, 0.0, 1.0));
            return;
		}

		tMax = max(0.0, tMax - atmosphereDistance);
	}

	int sampleCount = int(max(1.0, float(gl_GlobalInvocationID.z + 1.0) * 2.0));
	TransmittedLuminance transmittedLuminance = IntegrateScatteredLuminance(worldPosition, worldDirection, sunDirection, sampleCount, tMax);

	float averageTransmittance = (transmittedLuminance.transmittance.x + transmittedLuminance.transmittance.y + transmittedLuminance.transmittance.z) / 3.0;

	imageStore(aerialImage, ivec3(gl_GlobalInvocationID.xyz), vec4(transmittedLuminance.luminance, averageTransmittance));
}